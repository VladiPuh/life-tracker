from fastapi import FastAPI, Depends, HTTPException
from sqlalchemy import select, and_
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import date, datetime, timedelta
from apscheduler.schedulers.asyncio import AsyncIOScheduler

from .db import Base, engine, get_db, SessionLocal 
from .models import User, Challenge, DailyLog
from .schemas import ChallengeCreate, ChallengePatch, DailyFlagSet, TodayItem
from .settings import settings

app = FastAPI(title=settings.app_name)

def compute_status_view(log: DailyLog | None) -> str:
    if log is None:
        return "WAITING"
    if log.flag_bonus: return "BONUS"
    if log.flag_min: return "MIN"
    if log.flag_skip: return "SKIP"
    if log.flag_fail: return "FAIL"
    return "WAITING"

def apply_single_flag(log: DailyLog, flag: str):
    # сброс всех
    log.flag_min = log.flag_bonus = log.flag_skip = log.flag_fail = False
    # установка одного
    if flag == "MIN": log.flag_min = True
    elif flag == "BONUS": log.flag_bonus = True
    elif flag == "SKIP": log.flag_skip = True
    elif flag == "FAIL": log.flag_fail = True
    else: raise ValueError("Bad flag")

async def get_current_user(db: AsyncSession) -> User:
    # DEV: один фиксированный пользователь
    if settings.dev_auth:
        tid = settings.dev_user_telegram_id
        q = await db.execute(select(User).where(User.telegram_id == tid))
        user = q.scalar_one_or_none()
        if not user:
            user = User(telegram_id=tid, username="dev")
            db.add(user)
            await db.commit()
            await db.refresh(user)
        return user

    # TODO: PROD — проверка Telegram initData (сделаем следующим шагом)
    raise HTTPException(status_code=401, detail="Auth not configured")

@app.on_event("startup")
async def on_startup():
    # MVP: создаём таблицы автоматически (миграции подключим позже)
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    # Авто-assign как встроенный джоб (чтобы не мучить cron/Docker на старте)
    scheduler = AsyncIOScheduler(timezone="Europe/Vilnius")
    scheduler.add_job(auto_assign_missed, "cron", hour=23, minute=59)
    scheduler.start()

@app.get("/health")
async def health():
    return {"ok": True}

@app.post("/challenges")
async def create_challenge(payload: ChallengeCreate, db: AsyncSession = Depends(get_db)):
    user = await get_current_user(db)
    ch = Challenge(user_id=user.id, title=payload.title, description=payload.description, miss_policy=payload.miss_policy)
    db.add(ch)
    await db.commit()
    await db.refresh(ch)
    return {"id": ch.id}

@app.patch("/challenges/{challenge_id}")
async def patch_challenge(challenge_id: int, payload: ChallengePatch, db: AsyncSession = Depends(get_db)):
    user = await get_current_user(db)
    q = await db.execute(select(Challenge).where(and_(Challenge.id == challenge_id, Challenge.user_id == user.id)))
    ch = q.scalar_one_or_none()
    if not ch:
        raise HTTPException(404, "Challenge not found")

    data = payload.model_dump(exclude_unset=True)
    for k, v in data.items():
        setattr(ch, k, v)

    await db.commit()
    return {"ok": True}

@app.get("/today", response_model=dict)
async def today(db: AsyncSession = Depends(get_db)):
    user = await get_current_user(db)
    today_d = date.today()

    q = await db.execute(select(Challenge).where(and_(Challenge.user_id == user.id, Challenge.is_active == True, Challenge.is_template == False)).order_by(Challenge.id.asc()))
    challenges = q.scalars().all()

    items: list[TodayItem] = []
    first_waiting: TodayItem | None = None

    for ch in challenges:
        ql = await db.execute(select(DailyLog).where(and_(DailyLog.user_id == user.id, DailyLog.challenge_id == ch.id, DailyLog.date == today_d)))
        log = ql.scalar_one_or_none()
        status_view = compute_status_view(log)
        item = TodayItem(challenge_id=ch.id, title=ch.title, status_view=status_view)
        items.append(item)
        if first_waiting is None and status_view == "WAITING":
            first_waiting = item

    return {
        "date": str(today_d),
        "first_uncompleted": first_waiting.model_dump() if first_waiting else None,
        "all": [i.model_dump() for i in items],
    }

@app.post("/daily-log/upsert")
async def upsert_daily(payload: DailyFlagSet, db: AsyncSession = Depends(get_db)):
    user = await get_current_user(db)
    d = payload.date or date.today()

    # проверка существования челенджа
    q = await db.execute(select(Challenge).where(and_(Challenge.id == payload.challenge_id, Challenge.user_id == user.id)))
    ch = q.scalar_one_or_none()
    if not ch:
        raise HTTPException(404, "Challenge not found")

    ql = await db.execute(select(DailyLog).where(and_(DailyLog.user_id == user.id, DailyLog.challenge_id == ch.id, DailyLog.date == d)))
    log = ql.scalar_one_or_none()
    if not log:
        log = DailyLog(user_id=user.id, challenge_id=ch.id, date=d)
        db.add(log)

    apply_single_flag(log, payload.flag)
    log.minutes_fact = payload.minutes_fact
    log.comment = payload.comment

    await db.commit()
    return {"ok": True}

@app.get("/challenges/{challenge_id}/history")
async def challenge_history(challenge_id: int, days: int = 30, db: AsyncSession = Depends(get_db)):
    user = await get_current_user(db)
    since = date.today() - timedelta(days=days-1)

    q = await db.execute(
        select(DailyLog).where(
            and_(
                DailyLog.user_id == user.id,
                DailyLog.challenge_id == challenge_id,
                DailyLog.date >= since
            )
        ).order_by(DailyLog.date.desc())
    )
    logs = q.scalars().all()

    out = []
    for log in logs:
        out.append({
            "date": str(log.date),
            "status_view": compute_status_view(log),
            "minutes_fact": log.minutes_fact,
            "comment": log.comment,
        })
    return {"challenge_id": challenge_id, "items": out}

async def auto_assign_missed():
    """
    В 23:59 по Europe/Vilnius:
    - для каждого активного челенджа пользователя
    - если на сегодня нет записи в daily_log
    - создаём запись с флагом по miss_policy (по умолчанию FAIL)
    """
    today_d = date.today()

    async with SessionLocal() as db:
        # 1) Берём всех пользователей
        q_users = await db.execute(select(User))
        users = q_users.scalars().all()

        for user in users:
            # 2) Берём активные не-шаблонные челенджи
            q_ch = await db.execute(
                select(Challenge).where(
                    and_(
                        Challenge.user_id == user.id,
                        Challenge.is_active == True,
                        Challenge.is_template == False,
                    )
                )
            )
            challenges = q_ch.scalars().all()

            for ch in challenges:
                # 3) Есть ли уже лог на сегодня?
                q_log = await db.execute(
                    select(DailyLog).where(
                        and_(
                            DailyLog.user_id == user.id,
                            DailyLog.challenge_id == ch.id,
                            DailyLog.date == today_d,
                        )
                    )
                )
                existing = q_log.scalar_one_or_none()
                if existing:
                    continue  # пользователь уже отметил — не трогаем

                # 4) Создаём лог по политике пропуска
                policy = (ch.miss_policy or "FAIL").upper()

                log = DailyLog(user_id=user.id, challenge_id=ch.id, date=today_d)
                try:
                    apply_single_flag(log, policy)  # MIN/BONUS/SKIP/FAIL
                except Exception:
                    apply_single_flag(log, "FAIL")  # страховка

                db.add(log)

        await db.commit()
@app.post("/dev/run-auto-assign")
async def dev_run_auto_assign():
    await auto_assign_missed()
    return {"ok": True}
